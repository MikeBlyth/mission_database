# == Schema Information
# Schema version: 20110524121604
#
# Table name: statuses
#
#  id              :integer         not null, primary key
#  description     :string(255)
#  code            :string(255)
#  created_at      :datetime
#  updated_at      :datetime
#  active          :boolean
#  on_field        :boolean
#  pipeline        :boolean
#  leave           :boolean
#  home_assignment :boolean
#

class Status < ActiveRecord::Base
  include ModelHelper
  before_destroy :check_for_linked_records
  has_many :members
  has_many :families
  validates_uniqueness_of :code, :description
  validates_presence_of :code, :description

  # Class method Status.field_statuses and Status.active_statuses
  # Return array of status_ids for statuses of given category
  #   (i.e. if a member or family has this status, the member or family is considered 
  #   to be on the field)
  # Categories are represented by columns in the statuses table. 
  # The 'category' argument can be string or label if it's a single column.
  # AND/OR expressions can be used if so you can say Status.statuses_by_category('on_field or active')
  # or ...('on_field_or_active')
  def self.statuses_by_category(category)
    and_or = /_(and|or|not)_/i
    selected = self.where(category.to_s.gsub(and_or, ' \1 '))  # replace underscores by spaces around and/or
    ids = selected.map {|x| x.id}
    return ids
  end
    
  # Convenience methods
    def self.field_statuses
      self.statuses_by_category('on_field')
    end
    
    def self.home_assignment_statuses
      self.statuses_by_category('home_assignment')
    end
    
    def self.leave_statuses
      self.statuses_by_category('leave')
    end
    
    def self.pipeline_statuses
      self.statuses_by_category('pipeline')
    end
    
    def self.active_statuses
      self.statuses_by_category('active')
    end

    def self.all_statuses
      ids = self.all.map {|x| x.id}
    end
    
    # DEBT: all_statuses is generated by removing manually-listed groups of statuses,
    # so it's brittle. Better to reflect on the groups automatically so they can be
    # added dynamically.
    def self.other_statuses
      self.all_statuses - field_statuses-home_assignment_statuses-
                                        leave_statuses - pipeline_statuses -
                                        active_statuses
    end

    # Given a target group, such as "active", return statuses matching that group.
    # Mainly a wrapper on statuses_by_category to restrict to valid groups and
    # to handle "other" separately. 
    # * Just add more groups to existing_groups as long as they work
    # * If 'target_group' is not in 'existing_groups' then all statuses are returned
    # 
    # DEBT: This method is a weak point because it has to be manually adjusted to fit
    # any changes in status categories. 
    def self.statuses_by_group(target_group)
      existing_groups = %w(active leave on_field home_assignment home_assignment_or_leave pipeline other)
      return nil unless existing_groups.include?(target_group.to_s) # to match everything
      if target_group == 'other'  # treat separately since won't work in Status#statuses_by_category
        target_statuses = self.other_statuses
      else
        target_statuses = self.statuses_by_category(target_group)
      end
    end
    
    def self.filter_condition_for_group(table, target_group)
      target_statuses = self.statuses_by_group(target_group)
      if target_statuses
        return ["#{table}.status_id IN (?)", target_statuses]
      else
        return 'true'
      end
    end      

  def to_label
    self.to_s
  end
  
  def to_s
    self.description
  end

end
